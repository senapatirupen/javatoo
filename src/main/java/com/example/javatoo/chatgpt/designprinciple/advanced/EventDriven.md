The Event-driven architecture pattern is a popular architectural pattern in which components communicate and interact through events. Events are generated by components and then consumed by other components that are interested in those events. Here's an example of implementing the Event-driven architecture pattern in Java:

First, let's define the event and event listener interfaces:

```java
interface Event {
    // Empty marker interface for events
}

interface EventListener {
    void onEvent(Event event);
}
```

Next, let's create a class that acts as the event bus, responsible for registering event listeners and dispatching events to the appropriate listeners:

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class EventBus {
    private Map<Class<? extends Event>, List<EventListener>> eventListeners = new HashMap<>();

    public void registerListener(Class<? extends Event> eventType, EventListener listener) {
        List<EventListener> listeners = eventListeners.getOrDefault(eventType, new ArrayList<>());
        listeners.add(listener);
        eventListeners.put(eventType, listeners);
    }

    public void unregisterListener(Class<? extends Event> eventType, EventListener listener) {
        List<EventListener> listeners = eventListeners.getOrDefault(eventType, new ArrayList<>());
        listeners.remove(listener);
        eventListeners.put(eventType, listeners);
    }

    public void dispatchEvent(Event event) {
        List<EventListener> listeners = eventListeners.get(event.getClass());
        if (listeners != null) {
            for (EventListener listener : listeners) {
                listener.onEvent(event);
            }
        }
    }
}
```

In this example, we have the `EventBus` class that maintains a mapping of event types to lists of event listeners. The `registerListener()` method allows components to register themselves as listeners for specific event types. The `unregisterListener()` method allows components to unregister themselves as listeners. The `dispatchEvent()` method is responsible for dispatching events to the appropriate listeners.

Now, let's create a sample event and event listener:

```java
class UserLoggedInEvent implements Event {
    private String username;

    public UserLoggedInEvent(String username) {
        this.username = username;
    }

    public String getUsername() {
        return username;
    }
}

class UserLoggedInListener implements EventListener {
    public void onEvent(Event event) {
        if (event instanceof UserLoggedInEvent) {
            UserLoggedInEvent userLoggedInEvent = (UserLoggedInEvent) event;
            String username = userLoggedInEvent.getUsername();
            System.out.println("User logged in: " + username);
        }
    }
}
```

In this example, we have the `UserLoggedInEvent` class that represents a user login event. It implements the `Event` interface. We also have the `UserLoggedInListener` class that implements the `EventListener` interface. It handles the `UserLoggedInEvent` by extracting the username from the event and printing a log message.

Finally, let's see how we can use the Event-driven architecture:

```java
public class Main {
    public static void main(String[] args) {
        EventBus eventBus = new EventBus();

        UserLoggedInListener userLoggedInListener = new UserLoggedInListener();
        eventBus.registerListener(UserLoggedInEvent.class, userLoggedInListener);

        // Simulate a user login event
        UserLoggedInEvent userLoggedInEvent = new UserLoggedInEvent("john123");
        eventBus.dispatchEvent(userLoggedInEvent);

        // Unregister the listener
        eventBus.unregisterListener(UserLoggedInEvent.class, userLoggedInListener);

        // Simulate another user login event (no listener registered, so no output)
        eventBus.dispatchEvent(userLoggedInEvent);
    }
}
```

In this example, we create an instance of the `EventBus` class. We register a `UserLoggedInListener` as a listener

for `UserLoggedInEvent` events. We then simulate a user login event by creating an instance of `UserLoggedInEvent` and dispatching it through the event bus. The listener receives the event and prints a log message. Next, we unregister the listener, and when we dispatch the same event again, there is no listener registered, so no output is generated.

The Event-driven architecture pattern allows components to communicate and interact through events. It promotes loose coupling and decoupling of components by avoiding direct dependencies between them. Components can register themselves as listeners for specific event types and respond to events they are interested in. This pattern is particularly useful in scenarios where components need to react to asynchronous and loosely coupled events.